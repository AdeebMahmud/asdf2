The layout for the simulation (main.py)

import random, math

Classes:
    MindController
        __init__(self, s)

        int sidelength
        matrix intersections
        list portals
        int ticks

        void initinter(self, s)
        Portal decidedest(self, p)
        list pathfind(self, origin, dest)
        void? onetick(self)

        static char decidelightcolor(light)

    Intersection
        __init__(self, gc)

        list adjacents
        Middle middle
        list gridcoords
        list roads
        Sidewalk s1, s2, s3, s4

        Road getoppositeroad(r)

    Road
        __init__(self, p)

        Lane left, forward, right
        list lanes
        Intersection parent
        ZebraCrossing crossing
        Light light
        list temp
        float length

        void giveroad(self, obj)
        void onetick(self)

    Lane
        __init__(self, d, parent, c)

        list cars
        char direction
        Road parentroad

        float length
        int capacity

        bool isopen(self, targetroad)  checks ZebraCrossing and traffic light
        float calccapacity(self, length)
        bool isfull(self)

    ZebraCrossing
        __init__(self, parent)

        bool occupied
        list peds
        Light pedlight
        Road parentroad
        static? float length

    Light
        __init__(self, parent)

        char state
        char parenttype
        ZebraCrossing/Road parent

    Middle
        __init__(self, parent)

        float sidelength  # some multiple of 6
        Intersection parent
        list cars
        matrix occupiedpoints

        bool pathisclear(self, lane, targetroad)
        2xn matrix getpath(self, lane, targetroad, third)

    Sidewalk
        __init__(self, p, c1, c2)

        Intersection parent
        list peds
        ZebraCrossing crossing1, crossing2

    Portal
        __init__(self, road, pos)

        list cars
        list peds
        Road adjroad
        list finished
        int position

        static float carprob

        satic float pedprob
        void createcar(self)
        void createped(self)
        void deleteobj(self, c)
        void releasesome(self)
        void deletefinished(self)
        void onetick(self)

    Car
        __init__(self, p)

        # general facts
        Portal/Lane/Middle parent
        Portal destination
        list path
        bool reacheddest

        # stuff used in Middle
        list coords
        list motionvector
        list path
        int occupiedindex  # see Middle

        # stuff used in Middle and Lane
        float position
        float length
        float speed
        float acceleration
        float reactivity
        static float buffer

    Pedestrian
        __init__(self, p)

        float walkingspeed
        Sidewalk parent
        bool reacheddest
        bool iswalkking
        float waitingtimeleft
        float reactivity

        static float decidewalkingspeed()
        static float calcwalkingtime(length)


General:
A tick is 1/10 a second
Every time we go through we immediately decrease all reaction time/waiting time variables by 0.1 (one tick length in seconds)


Car/Ped generation:
    Every tick MindController calls onetick() on all Portal Classes
    The Portals decide based on Portal.carprob/pedprob whether to create a new Car and/or Pedestrian
        If one does, a Car and/or Pedestrian is made inside the Portal
        The destination(s) is/are decided as another portal with different field "position", which is 0, 1, 2, 3
        This way cars and people behave realistically

    Then the cars/peds are given to the "temp" field of the adjacent road
    The MindController then calls onetick() on the Roads
        The Roads go through their "temp" field and sort the cars and pedestrians
            If it is a Car then it looks at the first Intersection in Car.path and figures out if it's up, down, left, right based on Intersection.gridcoords
                Then checks if Lane.isfull(), if False, then sets Car.position, changes lots of fields, and places in Lane
                If True, then leaves Car in Road.temp
            If it is a Pedestrian then it checks Pedestrian.walkingtimeleft
                If it is > 0 we leave the Ped in Road.temp and decrease walkingtimeeft by a 0.1 (1 tick)
                If it is None, then we get Road.length and get walkingtimeleft directly proportional to that, and do nothing else
                If is <= 0 we then append the ped to Sidewalk.peds of the left sidewalk adjacent to the current Road and reset walkingtimeleft to None


Lane.isopen(self, currlane, targetroad):
    Check targetroad.crossing.occupied, if True, return False
    Check self.crossing.occupied, if True, return False
    Check area of Middle.pathisclear(self, targetroad), if False, return False
    return True


Middle.pathisclear(self, currlane, targetroad):
    Figure out if path should be straight or round
    Figure out which third of targetroad you want to reach, remember as 0, 1, 2 from left to right
        (0 if turning left, 1 if going forward, 2 if turning right)

    If it's a line, make a list of points, each time increasing either the x or y value by 1
    If it's round call Middle.getpath(currlane, targetroad, third)

    Take resulting path and


Middle.getpath(self, lane, targetroad, third):
    Create list path
    Calculate the "origin" of the circle, coords with values not in the Middle
    Let (o1,o2) be the origin
    Let a1 be clockwise angle (starting from right) from origin to center of lane
    Let a2 be similar for origin to targetroad's third
    Let r be radius (use pythagorean theorem)
    Let a = a1
    while a <= a2:
        Use formula (o1 + r * math.cos(a), o2 + r *  math.sin(a)) to get next point
        If that point != path[-1], append point to path
        a += 0.01 (FON)

    return path


Stuff inside road:
    Everytime onetick() is called on Road:
        It runs the neural network/whatever decision thing and changes Road.light.state accordingly
        It then calls onetick() on all 3 lanes:
            The Lane goes through Lane.cars that aren't None and don't have Car.reationdelay = None and does Car.reactiondelay -= 0.1
            Then it gets the first Car in Lane.cars
            If not Lane.isopen(targetroad):
                If Car.reactiondelay == None calculate that based on Car.reactivity
                If *               * == some integer subtract 0.1
                *                  * == 0 Do math with Car.position/buffer/acceleration/speed/reactiondelay and figure out how much to accelerate/decelerate and act accordingly
            Else:
            Check if Car.reactiondelay <= 0
                If True, we start increasing Car.speed based on Car.acceleration
            Then we gradually(?) push the car onto the middle with the same acceleration
            We then find the next car in Lane.cars and set Car.reactiondelay based on Car.reactivity


Stuff inside Middle:
    onetick():
        We loop through Middle.cars:
        Use math to predict path of each car
