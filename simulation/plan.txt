The layout for the simulation (main.py)

Classes:
    MindController
        __init__(self, s)

        int sidelength
        matrix intersections
        list portals
        int ticks

        void initinter(self, s)
        Portal decidedest(self, p)
        list pathfind(self, origin, dest)
        void? onetick(self)

        static char decidelightcolor(light)

    Intersection
        __init__(self, gc)

        list adjacents
        Middle middle
        list gridcoords
        list roads
        Sidewalk s1, s2, s3, s4

        Road getoppositeroad(r)

    Road
        __init__(self, p)

        Lane lef, forward, right
        list lanes
        Intersection parent
        ZebraCrossing crossing
        Light light
        list temp
        float length

        void giveroad(self, obj)
        void onetick(self)

    Lane
        __init__(self, d, parent, c)

        list cars
        char direction
        Road parentroad

        float length
        int capacity

        float calccapacity(self, length)
        bool isfull(self)

    ZebraCrossing
        __init__(self, parent)

        bool occupied
        int numberofpedestrians
        Light pedlight
        Road parentroad
        static? float length

    Light
        __init__(self, parent)

        char state
        char parenttype
        ZebraCrossing/Road parent

    Middle
        __init__(self, parent)

        float sidelength
        Intersection parent
        bool areaisclear(self, area)

    Sidewalk
        __init__(self, p, c1, c2)

        Intersection parent
        list peds
        ZebraCrossing crossing1, crossing2

    Portal
        __init__(self, road, pos)

        list cars
        list peds
        Road adjroad
        list finished
        int position

        static float carprob

        satic float pedprob
        void createcar(self)
        void createped(self)
        void deleteobj(self, c)
        void releasesome(self)
        void deletefinished(self)
        void onetick(self)

    Car
        __init__(self, p)

        Portal/Lane/Middle parent
        Portal destination
        list path
        float position
        list coords
        list motionvector
        bool reacheddest
        float length
        float speed
        float acceleration
        float reactivity

        static float buffer

    Pedestrian
        __init__(self, p)

        float walkingspeed
        Sidewalk parent
        bool reacheddest
        bool iswalkking
        float waitingtimeleft
        float reactivity

        static float decidewalkingspeed()
        static float calcwalkingtime(length)


General:
A tick is 1/10 a second
Every time we go through we immediaely decrease all reaction time/waiting time variables by 0.1 (one tick length in seconds)


Car/Ped generation:
    Every tick MindController calls onetick() on all Portal Classes
    The Portals decide based on Portal.carprob/pedprob whether to create a new Car and/or Pedestrian
        If one does, a Car and/or Pedestrian is made inside the Portal
        The destination(s) is/are decided as another portal with different field "position", which is 0, 1, 2, 3
        This way cars and people behave realistically

    Then the cars/peds are given to the "temp" field of the adjacent road
    The MindController then calls onetick() on the Roads
        The Roads go through their "temp" field and sort the cars and pedestrians
            If it is a Car then it looks at the first Intersection in Car.path and figures out if it's up, down, left, right based on Intersection.gridcoords
                Then checks if Lane.isfull(), if False, then sets Car.position, changes lots of fields, and places in Lane
                If True, then leaves Car in Road.temp
            If it is a Pedestrian then it checks Pedestrian.walkingtimeleft
                If it is > 0 we leave the Ped in Road.temp and decrease walkingtimeeft by a 0.1 (1 tick)
                If it is None, then we get Road.length and get walkingtimeleft directly proportional to that, and do nothing else
                If is <= 0 we then append the ped to Sidewalk.peds of the left sidewalk adjacent to the current Road and reset walkingtimeleft to None


Stuff inside road:
    Everytime onetick() is called on Road:
        It runs the neural network/whatever decision thing and changes Road.light.state accordingly
        It then calls onetick() on all 3 lanes:
            The Lane goes through Lane.cars that aren't None and don't have Car.reationdelay = None and does Car.reactiondelay -= 0.1
            Then it finds the first Car in Lane.cars that isn't None
            If Car.reactiondelay <= 0 then we check Middle.areaisclear(area) which is right in front of the Lane
                If True, we start increasing Car.speed based on Car.acceleration
            We then find the next car in Lane.cars and set Car.reactiondelay based on Car.reactivity
